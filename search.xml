<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>matlab学习记录(持续更新)</title>
      <link href="/2023/03/02/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/02/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="二维图"><a href="#二维图" class="headerlink" title="二维图"></a>二维图</h1><ol><li><code>x = 0:0.05:30;</code>从0到30，每隔0.05取一次值。</li><li><code>y = sin(x);</code></li><li><code>plot(x,y,&#39;LineWidth&#39;,2)</code>以x,y为条件绘制线图，linewidth可变粗。</li><li><code>grid on</code> 显示网格</li><li><code>axis(0 20 -1.5 1.5)</code> 横坐标显示0-20，纵坐标显示-1.5-1.5。</li><li><code>plot(x,y1,x,y2)</code>多组函数显示在一张图内。</li><li><code>bar(t,p)</code>创建垂直条形图</li><li><code>barh(t,p)</code>创建水平条形图</li><li><code>abs()</code>求绝对值或复数的模</li><li><code>polarplot(t,p)</code>绘制极坐标图</li><li><code>scatter(x,y)</code>绘制x,y的散点图</li><li><code>xlabel(&#39;abc&#39;)ylabel(&#39;abc&#39;)</code>横纵坐标的标题</li><li><code>randn(1000,1)</code>生成一个1000行1列的随机矩阵(符合正态分布)</li><li><code>exp(x)</code>输出e的x次方的结果</li></ol><hr><h1 id="三维图-和子图"><a href="#三维图-和子图" class="headerlink" title="三维图 和子图"></a>三维图 和子图</h1><ol><li><code>[X,Y] = meshgrid(-2:0.2:2)</code> -2到2的范围内没0.2取一次值，xy的范围均如此</li><li><code>Z=X.*exp(xxxxxxx)</code> xy和z的关系式</li><li><code>surf(X,Y,Z)</code> 生成函数的三维曲面图</li><li><code>colormap hsv/winter/summer</code>等 切换颜色布局</li><li><code>colorbar</code> 出现数值对应颜色的对比表</li><li><code>subplot(2,2,1)</code>在两行两列的图中放置第一个子图;<code>surf(X.^2);title(&#39;1st&#39;);</code></li></ol><hr><h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><p>Linprog函数；目标函数最小值，约束条件小于等于或等号。<br>若求最大值，则求目标函数负数的最小值，约束条件大于等于，则大于等于加一个负号<br><code>[x,fval]=linporg(f,A,Aeq,beq,lb,ub)</code><br><code>x</code>为最优解变量的取值，<code>fval</code>返回目标函数的最优值<br><code>A</code>,<code>b</code>为不等式约束条件的变量系数矩阵和常数项矩阵<br><code>Aeq</code>，<code>beq</code>为等式约束条件中的系数矩阵和常数项矩阵<br><code>lb</code>,<code>bu</code>为决策变量的最小取值和最大取值  </p><p>若不存在不等式约束，则用[]代替A和b：<code>[x,fval]=linprog(f,[],[],Aeq,beq,lb,ub) </code><br>若不存在等式约束，用[]代替Aeq和beq：<code>linprog(f,A,b, [],[],lb,ub)</code><br>没有等式约束和最小，最大取值的约束时，可以不写Aeq和beq和lb,ub:<code>[x,fval]=linprog(f,A,b)</code><br>若题目求最大值：目标函数等号两端加负号转为最小值<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/20e82b0230edfc2287729e632c3b57005492186f.png" alt="111">  </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f=[<span class="number">-40</span>;<span class="number">30</span>]; <span class="comment">%目标函数中变量的系数矩阵</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">1</span>;<span class="number">-1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">-1</span>;<span class="number">240</span>,<span class="number">120</span>];<span class="comment">%系数矩阵</span></span><br><span class="line">b=[<span class="number">6</span>;<span class="number">-1</span>;<span class="number">-1</span>;<span class="number">1200</span>]; <span class="comment">%常数项矩阵</span></span><br><span class="line">[x,y] = limprog(f,a,b)</span><br><span class="line">y= -y <span class="comment">%变求最小值为求最大值。</span></span><br></pre></td></tr></table></figure><hr><h1 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h1><ul><li>与线性规划的区别：线性规划所有变量都是一次方，而非线性规划所有变量都不是一次方。</li></ul><p>[x,fval] &#x3D; fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon)<br>fun为单独函数文件里定义的目标函数<br>x0为决策变量的初始值，不知道的话随便写一个就行<br>A,b是线性约束的不等式变量系数矩阵和常数项矩阵，都是(小于等于)<br>Aeq,beq是线性约束的等式变量<br>lb,ub为决策变量的最小取值和最大取值<br>nonlcon为非线性约束，包括不等式和等式<br>x为决策变量取值，fval为得到的最优解取值</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 建模 Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法总结</title>
      <link href="/2023/03/02/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/02/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>  今日我们相聚于此，是为了纪念我们的十大经典排序算法。它的存在对于整个至冬而言，值得足足十天甚至九天的停工学习（确信）<br>  ——————尼古拉斯·公只因sama</p><hr><p> 你说的对，但是《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「提瓦特」的幻想世界，在这里，被神选中的人将被授予「神之眼」，导引元素之力。你将扮演一位名为「旅行者」的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起击败强敌，找回失散的亲人——同时，逐步发掘「原神」的真相。</p><hr><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的意思是数组中的每个数像泡泡一样冒出水面做出排列。</p><p>若要深入理解该排序方法，请看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(length--)</span><br><span class="line"><span class="comment">//每确定一个最大值剩余需要排序的数量-1</span></span><br><span class="line"> &#123;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++);<span class="comment">//交换出最大值排到最末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=a[i];</span><br><span class="line">            a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，我们还可以对这段代码进行优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nt a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//新定义一个flag变量</span></span><br><span class="line"><span class="keyword">while</span>(length--&amp;&amp;flag)<span class="comment">//若flag为0，即前一次排序未发生交换，即排序已经完成，跳出循环，以达成优化。</span></span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="comment">//每确定一个最大值剩余需要排序的数量-1</span></span><br><span class="line"> &#123;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++);<span class="comment">//交换出最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])</span><br><span class="line">        &#123;   </span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//若此次循环中发生过数字交换，则flag为1，若未发生交换，则flag为0，代表该排序已经完成，不需要再进行排序。</span></span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=a[i];</span><br><span class="line">            a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>如果在题中忘记了冒泡排序的原理可以用多个for循环进行多次长度为length的冒泡循环，以至于半个泡都冒不出了，这样你就排序完成了！</del>（胡言乱语）</p><hr><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>本质其实还是冒泡排序，不过与冒泡排序不同的是无法像冒泡排序一样优化。<br>在每次循环中找到一个最小值，并以一个变量做标记，在此次循环结束后将其与第一个变量做交换，以此类推，从而使整个数组从小到大排序。（由大到小同理）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++);</span><br><span class="line"><span class="comment">//一共10个数，排9个即可</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">int</span> k=i;<span class="comment">//当前已知的最高位为默认的第一个数a[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[k])</span><br><span class="line">                k=j;<span class="comment">//当前已知的最高位变更为a[j]</span></span><br><span class="line">        <span class="type">int</span> temp =a [i];<span class="comment">//将已知的最高位与第i项做替换，达成排序目的。</span></span><br><span class="line">        a[i]=a[k];</span><br><span class="line">        a[k]=temp</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>优点：当原始序列基本有序的时候再将数据插入进来，比较方便，也比较高效。<br>其思路相与冒泡排序略微复杂，需要加强理解。<br>其原理是设定一个在数组开头的假想有序数组，每次将该有序数组的数量扩大一位，并将扩大的那一位插入到有序数组的适当位置中完成有序数组的重新排列，直到该有序数组排序完成且长度与原始序列相等，则排序完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)<span class="comment">//此次需要排10个整</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        <span class="comment">//因为第一个数形成了有序数列，并将有序数列的数量扩大至2，在不考虑a[1]数值的情况下，此次排列只需要交换a[1],故将a[i]赋值给临时变量temp</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">//此次排列为由大到小的降序排列，若a[i]的值与之前的有序数列的最后一位a[i-1]相比，a[i]比最小值大的话，则需要将a[i]插入到某一位置，若比最小值小，则无需排列。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;temp&lt;a[j];j--);</span><br><span class="line">            <span class="comment">//此处temp&lt;a[j]的含义是将temp排在第一个比其小的变量中，实现有序数组的降序排列</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">                <span class="comment">//由于temp的插入，有序数组中temp后的元素需要向后移动一位。</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//跳出循环后，将temp赋值给a[j]后面的a[j+1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的本质是插入排序的优化版，在面对比较大的数组时，插入排序总是会一个一个的插入，造成很大的计算量。在希尔排序中，我们先将原数以数组总长的二分之一为间距，每隔一个间距组成一个数组分别进行预插入排列，以此类推再以原数组总长的四分之一为间距进行插入1排列，最后会得到一个数组，对这个数组再进行一次插入排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nt a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i,temp,j,length=length/<span class="number">2</span>;<span class="comment">//length为间距</span></span><br><span class="line"><span class="keyword">while</span>(length&gt;<span class="number">0</span>)<span class="comment">//间距大于0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=length;i&lt;n;i=i+length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;a[j-length])<span class="comment">//对以length为间距的数组进行预插入排列</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[j];</span><br><span class="line">            a[j]=a[j-length];</span><br><span class="line">            a[j-length]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        length=length/<span class="number">2</span>;<span class="comment">//length为间距</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>冒泡排序为什么是神！！！</del></p><hr><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>冒泡排序plus+<br>在快速排序中使用了递归（即反复调用自身），当提到递归的时候，需要注意：要给出结束递归的条件，否则会变成死循环。<br>在快速排序中，你需要选定一个数作为轴数，并以这个轴数为轴，将比其大的数都放到右边，比其小的数都放到左边，完成第一次递归调用的函数的调用，随后将该轴数左右两侧的数组视为独立的单独数组，并对其进行再次递归函数的调用<br>在此借用（@五分钟学算法）的动图<br><img src="https://img-blog.csdnimg.cn/202002091953256.gif" alt="五分钟学算法"><br>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> i = low; <span class="comment">//low,high存为i,j</span></span><br><span class="line">    <span class="type">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) <span class="comment">//i=j则本次函数调用结束，可开启下次调用或结束。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> temp = <span class="built_in">array</span>[low];<span class="comment">//temp即为确定是轴数</span></span><br><span class="line">    <span class="keyword">while</span>(i != j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[j] &gt;= temp &amp;&amp; i &lt; j) <span class="comment">//找不到比原数组的上界位大的数则将j向后移动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">array</span>[i] &lt;= temp &amp;&amp; i &lt; j) <span class="comment">//找不到比原数组的下界位大的数则将i向后移动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j) <span class="comment">//swap即互换函数，在此不做定义</span></span><br><span class="line">        <span class="comment">//ij都找到了并且ij不相等是将对应的值互换</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    swap(<span class="built_in">array</span>[low], <span class="built_in">array</span>[i]);<span class="comment">//将基准temp放于自己的位置，（第i个位置）此时i并非low，i在此时满足i=j。</span></span><br><span class="line"> </span><br><span class="line">    QuickSort(<span class="built_in">array</span>, low, i - <span class="number">1</span>);<span class="comment">//对轴左侧数组进行快速排序函数调用</span></span><br><span class="line">    QuickSort(<span class="built_in">array</span>, i + <span class="number">1</span>, high);<span class="comment">//对轴右侧数组进行快速排序函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并：即将两个有序数列合并成一个有序数列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mergesort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> alen,<span class="type">int</span> b[],<span class="type">int</span> blen,<span class="type">int</span>* temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;alen&amp;&amp;j&lt;blen)<span class="comment">//先排一半进到temp[]里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;b[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k]=a[i];</span><br><span class="line">            k++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k]=b[j];</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;alen&gt;)<span class="comment">//再排后一半到temp[]里</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k]=a[i];</span><br><span class="line">        k++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;blen&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k]=b[i];</span><br><span class="line">        k++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="堆排序（内堆）（待更新）"><a href="#堆排序（内堆）（待更新）" class="headerlink" title="堆排序（内堆）（待更新）"></a>堆排序（内堆）（待更新）</h1><hr><h1 id="堆排序（外堆）（待更新）"><a href="#堆排序（外堆）（待更新）" class="headerlink" title="堆排序（外堆）（待更新）"></a>堆排序（外堆）（待更新）</h1><hr><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>利用数组下标本身的有序性完成排列。<br>代码极其简单。<br><img src="https://img-blog.csdnimg.cn/c43908d6854a4be38c68060f0293d79b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP54y_5qGl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="计数排序"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp[<span class="number">100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">countsort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[arr[i]]++;<span class="comment">//原数组的数到对应自定数组的对应下标+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>,j=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(temp[i]--)</span><br><span class="line">            arr[j++]=i;<span class="comment">//自定数组每有一个1则输出到arr[]一个对应的数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>非比较算法，将整数按照每个位数分别比较。<br>在此我借用（@小c哈哈哈）的文章来进行演示。<br><img src="https://img-blog.csdnimg.cn/2021012618502516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aV9oYWhhaGE=,size_16,color_FFFFFF,t_70" alt="1"><br><img src="https://img-blog.csdnimg.cn/2021012618565523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aV9oYWhhaGE=,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210126190427561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aV9oYWhhaGE=,size_16,color_FFFFFF,t_70"><br>将数按照个位数大小存放，并按顺序取出，然后将按照十位数大小存放，并按顺序取出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> temp[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> bucket[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">maxBit</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//行这些代码在求n个元素的最大值 </span></span><br><span class="line"><span class="type">int</span> maxData = data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(maxData&lt;data[i])</span><br><span class="line">maxData=data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些代码在求最大值的位数是多少 </span></span><br><span class="line"><span class="type">int</span> d=<span class="number">1</span>;    <span class="comment">//d用来计数最大值的位数，因为既然是一个数，肯定至少有1位，所以d初始化为1 </span></span><br><span class="line"><span class="keyword">while</span>(maxData&gt;=<span class="number">10</span>)  <span class="comment">//将最大值不断/10，计算位数 </span></span><br><span class="line">&#123;</span><br><span class="line">maxData/=<span class="number">10</span>;</span><br><span class="line">d++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">radixsort</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> n)</span>  <span class="comment">//基数排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> d = maxBit(data,n);  <span class="comment">//求出最大位数</span></span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=d;i++)   <span class="comment">//进行d次排序</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)   <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">&#123;</span><br><span class="line">bucket[j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)    <span class="comment">//统计每个桶的元素个数 </span></span><br><span class="line">&#123;</span><br><span class="line">k=(data[j]/radix)%<span class="number">10</span>;</span><br><span class="line">bucket[k]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键代码1 </span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            bucket[j] = bucket[j - <span class="number">1</span>] + bucket[j]; </span><br><span class="line">       </span><br><span class="line">       <span class="comment">//关键代码2 </span></span><br><span class="line"><span class="keyword">for</span>(j = n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) </span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            temp[bucket[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            bucket[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = temp[j];</span><br><span class="line">            </span><br><span class="line">        radix = radix * <span class="number">10</span>;  <span class="comment">//个位  -》 十位  -》百位 -》…… </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">34</span>,<span class="number">4</span>&#125;;   </span><br><span class="line">radixsort(a,<span class="number">4</span>);         <span class="comment">//a十待排序的数组 ，4是元素个数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode接入chatgpt</title>
      <link href="/2023/02/22/VScode%E6%8E%A5%E5%85%A5chatgpt/"/>
      <url>/2023/02/22/VScode%E6%8E%A5%E5%85%A5chatgpt/</url>
      
        <content type="html"><![CDATA[<p>随着Chatgpt的火爆，越来越多的人开始寻找更便捷的方式使用Chatgpt在工作和学习方面辅助自己。</p><p>Chatgpt已于2023年三月初被墙国内ip已经无法正常访问，请各位悉知。</p><p>本教程分为以下三个部分：  </p><ol><li>下载vscode以及为vscode配置c语言环境。  </li><li>openai-key的获取</li><li>将Chatgpt接入vscode</li></ol><hr><h1 id="下载vscode以及为vscode配置c语言环境"><a href="#下载vscode以及为vscode配置c语言环境" class="headerlink" title="下载vscode以及为vscode配置c语言环境"></a>下载vscode以及为vscode配置c语言环境</h1><h2 id="1-下载vscode下载链接"><a href="#1-下载vscode下载链接" class="headerlink" title="1. 下载vscode下载链接"></a>1. 下载vscode<a href="https://code.visualstudio.com/Download">下载链接</a></h2><p><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/2a5aebadf0f1b59db9adac2b3f7c551ad67dab61.png" alt="下载页面"><br>根据自己的系统来选择适合自己的vscode版本，我这里以windows版的vscode为例。<br>如果你嫌弃官网下载速度慢，可以通过我提供的链接下载截至发布日期最新版的vscode windows1.75.1版本。<br>链接：<a href="https://pan.baidu.com/s/1tS2S4EaJb5_eStXE9LuGFg?pwd=1145">百度网盘链接</a><br>提取码：1145   </p><h2 id="2-安装vscode"><a href="#2-安装vscode" class="headerlink" title="2. 安装vscode"></a>2. 安装vscode</h2><p>本步骤没什么要注意的，注意勾选同意协议，以及创建快捷方式即可。</p><h2 id="3-下载vscode自动配置c语言环境工具"><a href="#3-下载vscode自动配置c语言环境工具" class="headerlink" title="3.下载vscode自动配置c语言环境工具"></a>3.下载vscode自动配置c语言环境工具</h2><p><a href="https://github.com/VSCodeConfigHelper/v4">下载链接</a><br>本工具由北京大学谷雨同学开发。<br>点击Releasses下的v4.06<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/ec4ae3db9a7ff03ca431288d205cc51ff77b09c3.png" alt="下载页面"><br>在.7z文件处选择一个属于自己操作系统的文件并且点击下载。<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/32d1a3baf65b7f53598bf4873832c934b0dd43d2.png" alt="下载页面"></p><h2 id="4-配置c语言环境"><a href="#4-配置c语言环境" class="headerlink" title="4.配置c语言环境"></a>4.配置c语言环境</h2><p>接下来我以windows版为例。<br>在资源管理器右键解压到当前文件夹。<br>双击 vsch.exe打开程序。 </p><h3 id="1-确认vscode路径"><a href="#1-确认vscode路径" class="headerlink" title="1. 确认vscode路径"></a>1. 确认vscode路径</h3><h3 id="2-选择编译器"><a href="#2-选择编译器" class="headerlink" title="2. 选择编译器"></a>2. 选择编译器</h3><p>安装方式   </p><ul><li><ol><li>跟随c语言环境配置工具的教程安装(推荐，建议不成功再选用第二种方式)</li></ol></li><li><ol start="2"><li>手动安装方式。(如下)</li></ol></li></ul><p>我选用的是MinGW编译器6.3.0版本<br><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">下载链接</a><br>点击下载链接后，不要下载上面的文件，往下划到MinGW-W64 Online Installer下载列表。<br>如果你嫌下载太慢，可以通过我提供的百度网盘链接下载。<br>链接：<a href="https://pan.baidu.com/s/1oZYnZWDe5Lx1Hg4d8EDTTQ?pwd=1145">百度网盘</a><br>提取码：1145<br>下载完成后点击安装<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/e6339351e71fe125b9cb163a12c5668aca07f1e8.png" alt="安装界面"><br>Veision：选最高<br>Architechture：64位系统选 x86_64 32位系统选i686。(现在大多数系统都是64位的)<br>Threads:Windows系统选择win32  Linux、Unix、Mac OS 等选择posix。<br>Exception：选seh<br>然后无脑下一步。<br>完成安装。  </p><h3 id="3-选择工作文件夹"><a href="#3-选择工作文件夹" class="headerlink" title="3. 选择工作文件夹"></a>3. 选择工作文件夹</h3><h3 id="4-配置选项（默认即可）"><a href="#4-配置选项（默认即可）" class="headerlink" title="4. 配置选项（默认即可）"></a>4. 配置选项（默认即可）</h3><h3 id="5-配置完成"><a href="#5-配置完成" class="headerlink" title="5. 配置完成"></a>5. 配置完成</h3><p>按执行测试文件，若能成功运行，则成功。<br>参考文章：<a href="https://zhuanlan.zhihu.com/p/355510947">https://zhuanlan.zhihu.com/p/355510947</a>  </p><hr><h1 id="openai-key的获取"><a href="#openai-key的获取" class="headerlink" title="openai-key的获取"></a>openai-key的获取</h1><p><a href="https://auth0.openai.com/u/signup/identifier?state=hKFo2SBqaXBuQUQ2TkszRUhWRGN0UjBNd3cxX3pYR2hmN2xzQqFur3VuaXZlcnNhbC1sb2dpbqN0aWTZIGJzVVRBVXMxeGl3VWJQOUtJNGJJNFMxdWNVNkVNQlVSo2NpZNkgRFJpdnNubTJNdTQyVDNLT3BxZHR3QjNOWXZpSFl6d0Q">注册链接</a> </p><p> 注：(此方法需要乘坐魔法扫帚前往美国开启全局模式才可注册)<br> 更详细的注册方法请自行在网上查阅。还可以在网络上自行购买openai的账号。</p><p> 附：<a href="https://cloud.tencent.com/developer/article/2190154">注册openai账号的教程</a>（作者：JanYork_小简）</p><p> 在您拥有账号后，便可以开启接下来的教程<br> <img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/a22e42a612532fc8d2151a028c7fb9f87bf5baf9.png" alt="注册链接"><br> 点击屏幕右上角个人头像<br> <img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/f9678baa78c193ec73c50669b8ac7d3daa1fdbbb.png" alt="注册链接"> 点击“View API keys”选项<br> 然后在新出现的页面中点击“Creat new secert key”选项以生产apikey<br> (注意：此key要保存好，对于这个key，你只有这一次保存复制的机会)</p><hr><h1 id="将Chatgpt接入vscode"><a href="#将Chatgpt接入vscode" class="headerlink" title="将Chatgpt接入vscode"></a>将Chatgpt接入vscode</h1><h2 id="调节vscode到中文并应用chatgpt插件"><a href="#调节vscode到中文并应用chatgpt插件" class="headerlink" title="调节vscode到中文并应用chatgpt插件"></a>调节vscode到中文并应用chatgpt插件</h2><ul><li><p>打开已经配置好的vscode</p></li><li><p>点击最左侧扩展选项（左侧第四个）</p></li><li><p>搜索  Chinese (Simplified)  和 chatgpt中文版 两个插件</p></li><li><p>下载完成后需要重启vscode应用中文模式</p></li><li><p>由于国内模式过于垃圾我们要使用并配置国外模式  </p></li><li><p>由于chatgpt中文版插件内关于配置的教程已经描述的十分详细，故在此不多赘述。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=WhenSunset.chatgpt-china">chatgpt中文版配置国外模式教程</a></p></li><li><p>配置完成后可以使用左侧主侧栏第五个选项“Chat-Gpt中文版即可开始对话”</p></li><li><p>此外，选中具体代码即可让chatgpt对你的代码进行分析与解释。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Chatgpt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人常用网站分享</title>
      <link href="/2022/08/01/%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/"/>
      <url>/2022/08/01/%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="网易见外工作台"><a href="#网易见外工作台" class="headerlink" title="网易见外工作台"></a>网易见外工作台</h2><p><a href="https://jianwai.youdao.com/index/0">网易见外工作台</a><br>功能：登录网易账号即可使用  </p><ul><li>视频翻译，ai自动生成中英双语字幕，并且可将字幕文件导入pr等视频编辑软件进行再度编辑。</li><li>字幕翻译：将生肉的字幕文件上传至工作台，即可导出熟肉字幕。</li><li>文档翻译： 文档快速翻译，支持在线编辑与本地导出。</li><li>语言翻译，上传音频，即可自动生成对应视频音频的文字文档。</li><li>会议同传：（需付费）在线会议实时转写与同步翻译，支持文本的编辑与导出。</li><li>图片翻译：支持多场景下的文字识别，将识别结果一键翻译。</li></ul><hr><h2 id="中国科学技术大学测速网站"><a href="#中国科学技术大学测速网站" class="headerlink" title="中国科学技术大学测速网站"></a>中国科学技术大学测速网站</h2><p><a href="http://test.ustc.edu.cn/">中国科学技术大学测速网站</a><br>功能：简洁好用的测速网站</p><ul><li>可以测速网络延迟 延迟抖动 下载速度 上传速度 以及ipv6和ipv4</li></ul><hr><h2 id="MuseTransfer"><a href="#MuseTransfer" class="headerlink" title="MuseTransfer"></a>MuseTransfer</h2><p><a href="https://musetransfer.com/">MuseTransfer</a><br>功能：免费传输文件（不限速）（微信登录），并且支持收集文件。</p><hr><h2 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h2><p><a href="https://www.processon.com/">ProcessOn</a><br>功能：在线免费制图工具（微信登录），可以完美胜任制作流程如图等图片。</p><hr><h2 id="LearningMusic"><a href="#LearningMusic" class="headerlink" title="LearningMusic"></a>LearningMusic</h2><p><a href="https://learningmusic.ableton.com/zh-Hans/">LearningMusic</a><br>功能：简洁好用的的音乐学习网站，很有创意。分设有节奏，音符和音阶，和弦，贝斯，旋律，乐曲结构等章节，适合入门者学习。</p><hr><h2 id="大学生活质量指北"><a href="#大学生活质量指北" class="headerlink" title="大学生活质量指北"></a>大学生活质量指北</h2><p><a href="https://cn.colleges.chat/">大学生活质量指北</a><br>功能：一个由tg频道发起的调查项目，总结了国内各大高校的大学生活质量，有一定的参考价值。</p><hr><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><p><a href="https://www.runoob.com/">菜鸟教程</a><br>功能：网站内包含各种语言的学习教程以及有丰富的例子，是一个比较优秀的资&#x3D;语言资料网站和学习网站。</p><hr><h2 id="ocs网课助手"><a href="#ocs网课助手" class="headerlink" title="ocs网课助手"></a>ocs网课助手</h2><p><a href="https://docs.ocsjs.com/">ocs网课助手</a><br>专注于帮助大学生从网课中释放出来。让自己的时间把握在自己的手中。支持学习通自动刷课，答题，在网站内有丰富的教程以帮助使用。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 分享 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '1';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/优设好身体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '2';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/甜甜圈海报字体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '3';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/Consolas.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '4';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/HYTangMeiRen55W.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '5';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/MiSans.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '6';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/MiSans.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '7';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/ZhuZiAWan2.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '8';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/ZhuZiAWan2.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '9';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/ZhuZiAJuanJWD.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 链接样式 */#article-container a {  color: var(--theme-color);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-关于date-2023-1-9-13-54-00"><a href="#title-关于date-2023-1-9-13-54-00" class="headerlink" title="title:关于date :2023-1-9 13:54:00"></a>title:关于<br>date :2023-1-9 13:54:00</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
