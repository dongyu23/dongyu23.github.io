<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双链表与双循环链表</title>
      <link href="/2023/09/26/%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/09/26/%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><h2 id="功能：初始化-头插法-尾插法-删除-遍历"><a href="#功能：初始化-头插法-尾插法-删除-遍历" class="headerlink" title="功能：初始化 头插法 尾插法 删除 遍历"></a>功能：初始化 头插法 尾插法 删除 遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 存储数据的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span>   <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">// 为链表头节点分配内存</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data = <span class="number">0</span>;                            <span class="comment">// 初始化数据为0</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;                         <span class="comment">// 初始化next指向NULL，表示链表为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;pre = <span class="literal">NULL</span>;                          <span class="comment">// 初始化pre指向NULL，表示链表为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;                               <span class="comment">// 返回链表头节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    node-&gt;data = data;                         <span class="comment">// 设置新节点的数据</span></span><br><span class="line"></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;next;                   <span class="comment">// 新节点的next指向链表头节点的下一个节点</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>;                          <span class="comment">// 新节点的pre指向链表头节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next = node;                         <span class="comment">// 链表头节点的next指向新插入的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;                  <span class="comment">// 如果链表头节点后还有节点</span></span><br><span class="line">        node-&gt;next-&gt;pre = node;                <span class="comment">// 更新原链表头节点下一个节点的pre指针，使其指向新插入的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* head = <span class="built_in">list</span>-&gt;next;                    <span class="comment">// 从链表的第一个节点开始遍历</span></span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    node-&gt;data = data;                         <span class="comment">// 设置新节点的数据</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;                         <span class="comment">// 新节点位于链表尾部，所以其next指向NULL</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>;                          <span class="comment">// 新节点的pre指向链表头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;                       <span class="comment">// 找到链表尾部节点</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = node;                         <span class="comment">// 链表尾部节点的next指向新插入的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    Node* prev = <span class="built_in">list</span>;                          <span class="comment">// 用于保存前一个节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data) &#123;               <span class="comment">// 找到要删除的节点</span></span><br><span class="line">            prev-&gt;next = node-&gt;next;           <span class="comment">// 前一个节点的next指向要删除节点的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;          <span class="comment">// 如果要删除节点后还有节点</span></span><br><span class="line">                node-&gt;next-&gt;pre = prev;        <span class="comment">// 更新要删除节点的下一个节点的pre指针，使其指向前一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(node);                        <span class="comment">// 释放要删除的节点的内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Node* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    Node* p = <span class="built_in">list</span>-&gt;next;                      <span class="comment">// 从链表的第一个节点开始</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;                        <span class="comment">// 当节点不为NULL时循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);                <span class="comment">// 打印节点数据</span></span><br><span class="line">        p = p-&gt;next;                           <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                              <span class="comment">// 打印换行符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = initList();                   <span class="comment">// 初始化链表</span></span><br><span class="line"></span><br><span class="line">    headInsert(<span class="built_in">list</span>, <span class="number">3</span>);                       <span class="comment">// 在头部插入节点</span></span><br><span class="line">    headInsert(<span class="built_in">list</span>, <span class="number">4</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    delete(<span class="built_in">list</span>, <span class="number">3</span>);                           <span class="comment">// 删除节点值为3的节点</span></span><br><span class="line"></span><br><span class="line">    print(<span class="built_in">list</span>);                               <span class="comment">// 打印链表中的所有节点数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h1><h2 id="功能：初始化-头插法-尾插法-遍历"><a href="#功能：初始化-头插法-尾插法-遍历" class="headerlink" title="功能：初始化 头插法 尾插法  遍历"></a>功能：初始化 头插法 尾插法  遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 存储数据的成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span>   <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双循环链表，返回指向链表头节点的指针</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">// 为链表头节点分配内存</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data = <span class="number">0</span>;                            <span class="comment">// 初始化数据为0</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;                         <span class="comment">// 初始化next指向自身，表示链表为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;pre = <span class="built_in">list</span>;                          <span class="comment">// 初始化pre指向自身，表示链表为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头部插入新节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    node-&gt;data = data;                         <span class="comment">// 设置新节点的数据</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>;                          <span class="comment">// 设置新节点的pre指向链表头节点</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;next;                   <span class="comment">// 设置新节点的next指向原链表头节点的下一个节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next-&gt;pre = node;                    <span class="comment">// 更新原链表头节点下一个节点的pre指针</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next = node;                         <span class="comment">// 更新链表头节点的next指针，指向新插入的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾部插入新节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    node-&gt;data = data;                         <span class="comment">// 设置新节点的数据</span></span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>;                         <span class="comment">// 设置新节点的next指向链表头节点</span></span><br><span class="line">    <span class="comment">//list-&gt;per即为最后面的节点，无需使用while循环。</span></span><br><span class="line">    node-&gt;pre = <span class="built_in">list</span>-&gt;pre;                     <span class="comment">// 设置新节点的pre指向原链表尾节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;pre-&gt;next = node;                    <span class="comment">// 更新原链表尾节点的next指针</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;pre = node;                          <span class="comment">// 更新链表头节点的pre指针，指向新插入的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表中的所有节点数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Node* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    Node* node = <span class="built_in">list</span>-&gt;next;  <span class="comment">// 从链表的第一个节点开始</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="built_in">list</span>) &#123;    <span class="comment">// 当节点不等于链表头节点时循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);  <span class="comment">// 打印节点数据</span></span><br><span class="line">        node = node-&gt;next;          <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = initList();    <span class="comment">// 初始化双循环链表</span></span><br><span class="line"></span><br><span class="line">    headInsert(<span class="built_in">list</span>, <span class="number">1</span>);        <span class="comment">// 在头部插入节点</span></span><br><span class="line">    headInsert(<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>, <span class="number">6</span>);        <span class="comment">// 在尾部插入节点</span></span><br><span class="line"></span><br><span class="line">    print(<span class="built_in">list</span>);                <span class="comment">// 打印链表中的所有节点数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表与单循环链表</title>
      <link href="/2023/09/24/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/09/24/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="单链表的实现（详细注释版）"><a href="#单链表的实现（详细注释版）" class="headerlink" title="单链表的实现（详细注释版）"></a>单链表的实现（详细注释版）</h1><h2 id="包含-初始化-头插法-尾插法-查找-计数-删除"><a href="#包含-初始化-头插法-尾插法-查找-计数-删除" class="headerlink" title="包含 初始化 头插法 尾插法 查找 计数 删除"></a>包含 初始化 头插法 尾插法 查找 计数 删除</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">//定义单链表</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指向下一个的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>&#123;</span><br><span class="line">    Node* <span class="built_in">list</span> =(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//新建头节点 头节点不赋值，便于后续插入，所有数据的存储都与头节点无关。</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data=<span class="number">0</span>;<span class="comment">//数据为0</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next=<span class="literal">NULL</span>;<span class="comment">//next为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;<span class="comment">//返回list</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>,<span class="type">int</span> data)</span>&#123;<span class="comment">//头插法</span></span><br><span class="line">    Node *node =(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//定义一个新节点</span></span><br><span class="line">    node-&gt;data=data;<span class="comment">//将数据导入新节点以便导入</span></span><br><span class="line">    node-&gt;next=<span class="built_in">list</span>-&gt;next;<span class="comment">//让node指向list的下一个节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next=node; <span class="comment">//把list放在node前一位即（list-&gt;node-&gt;其他节点）</span></span><br><span class="line">    <span class="comment">//再次插入时（list-&gt;node(新)-&gt;node-&gt;其他节点）新node总是在老node前方，即为头插法</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data++;<span class="comment">//数量++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* <span class="built_in">list</span>,<span class="type">int</span> data)</span>&#123;<span class="comment">//尾插法</span></span><br><span class="line">    Node *head=<span class="built_in">list</span>;<span class="comment">//导入list</span></span><br><span class="line">    Node *node =(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//定义一个新节点</span></span><br><span class="line">    node-&gt;data=data;<span class="comment">//将数据导入新节点以便导入</span></span><br><span class="line">    node-&gt;next=<span class="literal">NULL</span>;<span class="comment">//新节点由于要插入在尾部，next为null</span></span><br><span class="line">    <span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    &#125;<span class="comment">//使用list找到最后的节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next=node;<span class="comment">//把新定义的node插入尾部，即（list-&gt;....-&gt;node）</span></span><br><span class="line">    <span class="comment">//再一次插入时（list-&gt;....-&gt;node-&gt;node(新)）每次都在最后面插入，即为尾插法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Node* <span class="built_in">list</span>,<span class="type">int</span> data)</span>&#123;<span class="comment">//删除 </span></span><br><span class="line">    Node* pre=<span class="built_in">list</span>;<span class="comment">//删除需要找到对应节点的前一个节点，让其直接指向想删除的节点的下一个节点，所以设立pre</span></span><br><span class="line">    <span class="comment">//pre始终表示的时current前面的元素</span></span><br><span class="line">    Node* current=<span class="built_in">list</span>-&gt;next;<span class="comment">//由于头节点为空，直接从list的next开始寻找</span></span><br><span class="line">    <span class="keyword">while</span>(current)&#123;<span class="comment">//当前遍历所处的节点为非空</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;data==data)&#123;</span><br><span class="line">            pre-&gt;next=current-&gt;next;<span class="comment">//current的下一个改为由pre-&gt;next指向,链表由此略过current</span></span><br><span class="line">            <span class="built_in">free</span>(current);<span class="comment">//释放current</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//删除成功，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=current;</span><br><span class="line">        current=current-&gt;next;<span class="comment">//pre和current整体向前移动一个位置，继续进行循环并判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Node* <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    Node* node=<span class="built_in">list</span>-&gt;next;<span class="comment">//从第一个实际节点开始计数</span></span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        sum++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;<span class="comment">//第一个头节点的下一位开始遍历，因为第一位不储存数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>)&#123;<span class="comment">//遍历</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">list</span>-&gt;data);</span><br><span class="line">        <span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    Node* <span class="built_in">list</span>=initList();<span class="comment">//返回值为Node*类型</span></span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">1</span>);<span class="comment">//测试</span></span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">8</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,count(<span class="built_in">list</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="单循环链表的实现（原理同单链表）"><a href="#单循环链表的实现（原理同单链表）" class="headerlink" title="单循环链表的实现（原理同单链表）"></a>单循环链表的实现（原理同单链表）</h1><h2 id="包含-初始化-头插法-尾插法-计数-删除"><a href="#包含-初始化-头插法-尾插法-计数-删除" class="headerlink" title="## 包含 初始化 头插法 尾插法 计数 删除"></a>## 包含 初始化 头插法 尾插法 计数 删除</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">//定义单链表</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指向下一个的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>&#123;</span><br><span class="line">    Node* <span class="built_in">list</span> =(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="built_in">list</span>-&gt;data=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next=<span class="built_in">list</span>;<span class="comment">//循环单链表与单链表的区别，首尾相连</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>,<span class="type">int</span> data)</span>&#123;<span class="comment">//头插法</span></span><br><span class="line">    Node *node =(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data=data;</span><br><span class="line">    node-&gt;next=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next=node; </span><br><span class="line">    <span class="built_in">list</span>-&gt;data++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* <span class="built_in">list</span>,<span class="type">int</span> data)</span>&#123;<span class="comment">//尾插法</span></span><br><span class="line">    Node *head=<span class="built_in">list</span>;<span class="comment">//导入list,原list并没有变化，只是复制了一个与list一样的单链表</span></span><br><span class="line">    Node *node =(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//定义一个新节点</span></span><br><span class="line">    node-&gt;data=data;<span class="comment">//将数据导入新节点以便导入</span></span><br><span class="line">    <span class="comment">//node-&gt;next=NULL;</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next!= <span class="built_in">list</span>)&#123;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next=<span class="built_in">list</span>;</span><br><span class="line">    head-&gt;next=node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    Node* node=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="built_in">list</span>)&#123;<span class="comment">//当list回到第一个节点时停止print循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;data);</span><br><span class="line">        node=node-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Node* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">   Node* node=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="built_in">list</span>)&#123;<span class="comment">//当list回到第一个节点时停止print循环</span></span><br><span class="line">        sum++;</span><br><span class="line">        node=node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(Node* <span class="built_in">list</span>,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node* pre =<span class="built_in">list</span>;</span><br><span class="line">    Node* current=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(current!=<span class="built_in">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;data==data)&#123;</span><br><span class="line">            pre-&gt;next=current-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(current);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current=current-&gt;next;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">Node* <span class="built_in">list</span>=initList();<span class="comment">//返回值为Node*类型</span></span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">1</span>);<span class="comment">//测试</span></span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//printList(list);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count(<span class="built_in">list</span>));</span><br><span class="line">    Delete(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="有头节点的单链表与无头节点的单链表的区别"><a href="#有头节点的单链表与无头节点的单链表的区别" class="headerlink" title="有头节点的单链表与无头节点的单链表的区别"></a>有头节点的单链表与无头节点的单链表的区别</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单链表的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 数据域</span></span><br><span class="line">    node* next;         <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">&#125; Node, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个无头节点的单链表</span></span><br><span class="line">LinkList <span class="title function_">Create_Tail_NoHead</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkList tail = <span class="literal">NULL</span>, tmp;  <span class="comment">// 初始化尾指针为NULL和一个临时指针tmp</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; value;                <span class="comment">// 读取用户输入的第一个值</span></span><br><span class="line">    LinkList L = <span class="literal">NULL</span>;           <span class="comment">// 初始化链表指针为NULL</span></span><br><span class="line">    <span class="keyword">while</span> (value != <span class="number">-1</span>) &#123;        <span class="comment">// 当用户输入-1时，结束链表创建</span></span><br><span class="line">        tmp = new Node;          <span class="comment">// 为新节点分配内存</span></span><br><span class="line">        tmp-&gt;data = value;       <span class="comment">// 将用户输入的值赋给新节点的数据域</span></span><br><span class="line">        tmp-&gt;next = <span class="literal">NULL</span>;        <span class="comment">// 新节点的指针域设置为NULL</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;         <span class="comment">// 如果链表为空</span></span><br><span class="line">            L = tmp;             <span class="comment">// 新节点成为链表的第一个节点</span></span><br><span class="line">            tail = L;            <span class="comment">// 更新尾指针指向新节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = tmp;    <span class="comment">// 否则，将新节点添加到链表的尾部</span></span><br><span class="line">            tail = tmp;          <span class="comment">// 更新尾指针指向新节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;            <span class="comment">// 读取用户的下一个输入值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;                    <span class="comment">// 返回链表的开始地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个有头节点的单链表</span></span><br><span class="line">LinkList <span class="title function_">Create_Tail_WithHead</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkList head = new Node;    <span class="comment">// 为头节点分配内存</span></span><br><span class="line">    head-&gt;data = <span class="number">0</span>;              <span class="comment">// 为头节点的数据域赋值（此值通常无实际意义）</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;           <span class="comment">// 设置头节点的指针域为NULL</span></span><br><span class="line"></span><br><span class="line">    LinkList tail = head, tmp;   <span class="comment">// 初始化尾指针指向头节点和一个临时指针tmp</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; value;                <span class="comment">// 读取用户输入的第一个值</span></span><br><span class="line">    <span class="keyword">while</span> (value != <span class="number">-1</span>) &#123;        <span class="comment">// 当用户输入-1时，结束链表创建</span></span><br><span class="line">        tmp = new Node;          <span class="comment">// 为新节点分配内存</span></span><br><span class="line">        tmp-&gt;data = value;       <span class="comment">// 将用户输入的值赋给新节点的数据域</span></span><br><span class="line">        tmp-&gt;next = <span class="literal">NULL</span>;        <span class="comment">// 新节点的指针域设置为NULL</span></span><br><span class="line"></span><br><span class="line">        tail-&gt;next = tmp;        <span class="comment">// 将新节点添加到链表的尾部</span></span><br><span class="line">        tail = tmp;              <span class="comment">// 更新尾指针指向新节点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;            <span class="comment">// 读取用户的下一个输入值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;                 <span class="comment">// 返回头节点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Create No-Head List (end with -1):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    LinkList noHeadList = Create_Tail_NoHead();  <span class="comment">// 创建无头节点链表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Create With-Head List (end with -1):&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    LinkList withHeadList = Create_Tail_WithHead();  <span class="comment">// 创建有头节点链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以继续使用 Show_NoHead 函数来打印链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详细解释两者的区别并提供示例："><a href="#详细解释两者的区别并提供示例：" class="headerlink" title="详细解释两者的区别并提供示例："></a>详细解释两者的区别并提供示例：</h2><ol><li>无头节点的单链表：<br>它的第一个节点就是存储数据的节点。<br>通常，链表的起始地址指针直接指向第一个数据元素。<br>例如：</li></ol><p><code>L --&gt; 1 --&gt; 3 --&gt; 5</code></p><p>在这个例子中，L 直接指向数据 1 的节点。</p><ol><li>有头节点的单链表：<br>它有一个特殊的节点作为链表的起始，这个节点称为“头节点”。<br>头节点通常不用来存储数据（或者说其数据字段的值没有实际意义）。<br>头节点的存在可以简化链表中某些操作的实现，如插入、删除等。<br>例如：</li></ol><p><code>L --&gt; HEAD --&gt; 1 --&gt; 3 --&gt; 5</code><br>在这个例子中，L 指向一个特殊的 HEAD 节点，而 HEAD 的下一个节点才是第一个数据元素 1。</p><p>·区别：<br>节点开始位置：无头节点的链表从第一个数据开始，而有头节点的链表从一个特殊节点（头节点）开始。</p><p>操作的统一性：有头节点的链表在进行插入、删除等操作时，代码的实现可以更加统一，不需要特殊处理链表的开头和结尾。</p><p>空链表的表示：对于无头节点的链表，空链表是一个 NULL 指针。而对于有头节点的链表，即使链表中没有数据，它也有一个头节点。</p><p>空间使用：有头节点的链表会使用额外的空间来存储头节点，但这通常是一个很小的开销。</p><p>总的来说，选择使用哪种类型的链表取决于特定的应用和操作的需求。在某些情境下，有头节点的链表可能更为方便，因为它可以简化某些操作的代码实现。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习记录(持续更新)</title>
      <link href="/2023/03/02/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/02/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="二维图"><a href="#二维图" class="headerlink" title="二维图"></a>二维图</h1><ol><li><code>x = 0:0.05:30;</code>从0到30，每隔0.05取一次值。</li><li><code>y = sin(x);</code></li><li><code>plot(x,y,&#39;LineWidth&#39;,2)</code>以x,y为条件绘制线图，linewidth可变粗。</li><li><code>grid on</code> 显示网格</li><li><code>axis(0 20 -1.5 1.5)</code> 横坐标显示0-20，纵坐标显示-1.5-1.5。</li><li><code>plot(x,y1,x,y2)</code>多组函数显示在一张图内。</li><li><code>bar(t,p)</code>创建垂直条形图</li><li><code>barh(t,p)</code>创建水平条形图</li><li><code>abs()</code>求绝对值或复数的模</li><li><code>polarplot(t,p)</code>绘制极坐标图</li><li><code>scatter(x,y)</code>绘制x,y的散点图</li><li><code>xlabel(&#39;abc&#39;)ylabel(&#39;abc&#39;)</code>横纵坐标的标题</li><li><code>randn(1000,1)</code>生成一个1000行1列的随机矩阵(符合正态分布)</li><li><code>exp(x)</code>输出e的x次方的结果</li></ol><hr><h1 id="三维图-和子图"><a href="#三维图-和子图" class="headerlink" title="三维图 和子图"></a>三维图 和子图</h1><ol><li><code>[X,Y] = meshgrid(-2:0.2:2)</code> -2到2的范围内没0.2取一次值，xy的范围均如此</li><li><code>Z=X.*exp(xxxxxxx)</code> xy和z的关系式</li><li><code>surf(X,Y,Z)</code> 生成函数的三维曲面图</li><li><code>colormap hsv/winter/summer</code>等 切换颜色布局</li><li><code>colorbar</code> 出现数值对应颜色的对比表</li><li><code>subplot(2,2,1)</code>在两行两列的图中放置第一个子图;<code>surf(X.^2);title(&#39;1st&#39;);</code></li></ol><hr><h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><p>Linprog函数；目标函数最小值，约束条件小于等于或等号。<br>若求最大值，则求目标函数负数的最小值，约束条件大于等于，则大于等于加一个负号<br><code>[x,fval]=linporg(f,A,Aeq,beq,lb,ub)</code><br><code>x</code>为最优解变量的取值，<code>fval</code>返回目标函数的最优值<br><code>A</code>,<code>b</code>为不等式约束条件的变量系数矩阵和常数项矩阵<br><code>Aeq</code>，<code>beq</code>为等式约束条件中的系数矩阵和常数项矩阵<br><code>lb</code>,<code>bu</code>为决策变量的最小取值和最大取值  </p><p>若不存在不等式约束，则用[]代替A和b：<code>[x,fval]=linprog(f,[],[],Aeq,beq,lb,ub) </code><br>若不存在等式约束，用[]代替Aeq和beq：<code>linprog(f,A,b, [],[],lb,ub)</code><br>没有等式约束和最小，最大取值的约束时，可以不写Aeq和beq和lb,ub:<code>[x,fval]=linprog(f,A,b)</code><br>若题目求最大值：目标函数等号两端加负号转为最小值<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/20e82b0230edfc2287729e632c3b57005492186f.png" alt="111">  </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f=[<span class="number">-40</span>;<span class="number">30</span>]; <span class="comment">%目标函数中变量的系数矩阵</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">1</span>;<span class="number">-1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">-1</span>;<span class="number">240</span>,<span class="number">120</span>];<span class="comment">%系数矩阵</span></span><br><span class="line">b=[<span class="number">6</span>;<span class="number">-1</span>;<span class="number">-1</span>;<span class="number">1200</span>]; <span class="comment">%常数项矩阵</span></span><br><span class="line">[x,y] = limprog(f,a,b)</span><br><span class="line">y= -y <span class="comment">%变求最小值为求最大值。</span></span><br></pre></td></tr></table></figure><hr><h1 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h1><ul><li>与线性规划的区别：线性规划所有变量都是一次方，而非线性规划所有变量都不是一次方。</li></ul><p><code>[x,fval] = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon)  </code><br><code>fun</code>为单独函数文件里定义的目标函数<br><code>x0</code>为决策变量的初始值，不知道的话随便写一个就行<br><code>A</code>,<code>b</code>是线性约束的不等式变量系数矩阵和常数项矩阵，都是(小于等于)<br><code>Aeq</code>,<code>beq</code>是线性约束的等式变量<br><code>lb</code>,<code>ub</code>为决策变量的最小取值和最大取值<br><code>nonlcon</code>为非线性约束，包括不等式和等式<br><code>x</code>为决策变量取值，<code>fval</code>为得到的最优解取值<br>（收益率最大）（角度，涉及三角函数）（目标函数或限制条件含有非线性变量）  </p><hr><h1 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h1><ol><li>衡量每个目标的完全情况：  <ul><li>正负偏差变量，尽量不少于，意味着负偏差变量越小越好</li><li>绝对约束：是模型自带的约束条件，必须满足，否则不可解</li><li>目标约束：是模型中对不等式有段追求的值允许有偏差（偏差就是加入正负偏差变量）</li></ul></li><li>主观区分三个目标的重要性<ul><li>优先因子：到底哪个最重要</li></ul></li><li>使得整体的完成情况尽量好<ul><li>正偏差系数越小越好</li><li>把所有的目标约束都加上正负偏差变量变成等式<br>求解方法：fgoalattain函数&#x2F;序贯算法&#x2F;Lingo求解<br>（使…最大同时提及“尽量”）</li></ul></li></ol><hr><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p> 使用Dijkstar算法，或matlab的graphshortestpath函数<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">% sparse生成稀疏矩阵,就是除了注明的元素，其余1均为0</span></span><br><span class="line"> W = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>]</span><br><span class="line"> DG = sparse([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],...</span><br><span class="line">            [<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],W)</span><br><span class="line"><span class="comment">% 即1到2距离为10......</span></span><br><span class="line"><span class="comment">% ...即为matlab换行</span></span><br><span class="line">[dist,path,pred] = graphshortestpath(DG,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">% dist为最短路径的值，path是最短路径的节点顺序</span></span><br><span class="line"><span class="comment">% pred是每个节点的最短路径的终点前一个节点</span></span><br><span class="line"><span class="comment">% 如果求节点1到其他所有节点的最短路径呢？</span></span><br><span class="line">point_name = [<span class="string">&quot;城市1&quot;</span>,<span class="string">&quot;城市2&quot;</span>,<span class="string">&quot;城市3&quot;</span>,<span class="string">&quot;城市4&quot;</span>,<span class="string">&quot;城市5&quot;</span>]</span><br><span class="line"><span class="comment">% biograph生成图对象；view显示该图</span></span><br><span class="line">h = view(biograph(DG,point_name,<span class="string">&#x27;ShowWeights&#x27;</span>,<span class="string">&#x27;on&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">% 将最短路径的节点和边缘标记为红色并增加线宽</span></span><br><span class="line"><span class="comment">% getedgebynodeid得到图h的指定边的句柄</span></span><br><span class="line"><span class="comment">% 第一个参数是图，第二个是边的出点，第三个是边的入点</span></span><br><span class="line"><span class="comment">% 句柄确保能找到对应的东西</span></span><br><span class="line"><span class="comment">% get查询图的1属性，h.Node(path),&#x27;ID&#x27;得到图h中最短路径的</span></span><br><span class="line"><span class="comment">% set函数设置图形属性</span></span><br><span class="line">edges = getedgesbynodeid(h,get(h.Nodes(path),<span class="string">&#x27;ID&#x27;</span>))</span><br><span class="line">set(edges,<span class="string">&#x27;LineColor&#x27;</span>,[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]) <span class="comment">% RGB数值，红绿蓝</span></span><br><span class="line">set(edges,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>) </span><br></pre></td></tr></table></figure></p><hr><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>连通所有顶点且总路径最小</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>]</span><br><span class="line">weights = [<span class="number">50</span>,<span class="number">60</span>,<span class="number">65</span>,<span class="number">40</span>,<span class="number">52</span>,<span class="number">45</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">42</span>,<span class="number">70</span>];</span><br><span class="line"><span class="comment">% 生成无向图，其中s和t对应元素代表着边，weights是权值</span></span><br><span class="line">G = graph(s,t,weights);</span><br><span class="line">T= minspantree(G);</span><br><span class="line"><span class="comment">% p = plot(G)就能把图片展示出来，后面是为了美观设置字体等</span></span><br><span class="line">p = <span class="built_in">plot</span>(G,<span class="string">&#x27;EdgeLabel&#x27;</span>,G,edges.Weight,<span class="string">&quot;MarkerSize&quot;</span>,<span class="number">8</span>)</span><br><span class="line"><span class="comment">% 突出显示绘制的图中的节点和边</span></span><br><span class="line">highlight(p,T,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&quot;LineWidth&quot;</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>Kruskal算法：</li></ul><ol><li>把图中的所有边全部去掉，得到所有单独的顶点V构成图T&#x3D;(V,{})其中V是顶点集合。  </li><li>从G中取出当前权值最小（长度最小）的边，如果该边加入T的边集合后T不形成回路（绕成圈），则加入T；否则舍弃。 </li><li>重复第二步，直到T中有n-1条边（n是顶点数）<br>若第二步中遇到两条权值相同的最小权值边，任选一条即可，所以最小生成树可能不唯一，但权值之和相同。<br>(适合点多边少的图)</li></ol><ul><li>Prim算法</li></ul><ol><li>设置一个图U，将原图U中任意一顶点取出加入U中。</li><li>在所有的属于U的顶点中找到与目前包含的顶点顶点直接相连到目前不包含的点的权值最小的边，并加入该边和顶点到图U中。 </li><li>重复步骤2，直到u中包含了所有的顶点。<br>若第二步中遇到两条权值相同的最小权值边，任选一条即可，所以最小生成树可能不唯一，但权值之和相同。<br>（适合边多点少的图）</li></ol><hr><h1 id="灰色预测GM-1-1"><a href="#灰色预测GM-1-1" class="headerlink" title="灰色预测GM(1,1)"></a>灰色预测GM(1,1)</h1><p>(1,1);一阶微分方程，只有一个变量。<br>特点：数据少，看不出明显规律，适合用灰色预测。<br>看不出规律就制造规律。<br>累加生成序列；第k个数等于原始序列中前k个数相加。<br>发现这个直线或曲线看起来像一个1指数曲线或曲线，则构建一阶常微分方程来求解拟合曲线的函数表达式。<br>（不会，听蒙了0_o!?）  </p><hr><h1 id="神经网络之感知机"><a href="#神经网络之感知机" class="headerlink" title="神经网络之感知机"></a>神经网络之感知机</h1><ul><li>输入层：接收输入信号。</li><li>激活函数：综合判断输入信号是否达到阈值</li><li>输出层：激活函数，求得函数值。</li><li>线性加权求和以达到综合考虑。</li><li>设阈值为b，激活函数的自变量为线性求和-b。差值越大，越容易判断。</li><li>学习：从已知数据中学得模型（确定权重） </li><li>  学习过程：</li></ul><ol><li>模型初始化，认为主观的设置权重（查文献，靠经验）</li><li>搜集大量数据，作为训练数据集。 </li><li>将数据代入模型，求得估计值。</li><li>将估计值与实际值比较，差别越小越好。</li><li>若为满足终止条件，则继续对权重进行优化，得到新的权值，再重复3中的终止条件，直到估计值和实际值的差别小到一定程度为止。<br>感知机的优化方法：将权重改为<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/2ab5f2321496b0c03233e1e79e9a16b4f522bd11.png"></li></ol><hr><h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><p>模型的建立：</p><ol><li>目标层：</li><li>准则层：</li><li>方案层：<br>判断矩阵：对指标的重要性进行两辆比较，构造判断矩阵，从而求出权重。<br>不一致出现的原因：两两比较<br>一致性检验<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/8cbf133a64ef17338bf221ca61e3edfb63fb4123.png"><br>如果CR&#x3D;0则判断矩阵是一致矩阵<br>如果CR&lt;0.1则差异不大，通过一致性检验。<br>否则，需要修改矩阵，直到CR&lt;0.1<br>算数平均法求权重：将判断矩阵按列归一化，然后每一行分别求和，求和的结果除以n，得到的列向量就是权重向量。<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/7a8744e32abf5f891fd23e6194d83d825875e470.png"></li></ol><hr><h1 id="蚁群算法"><a href="#蚁群算法" class="headerlink" title="蚁群算法"></a>蚁群算法</h1><p>旅行商(TSP)问题:<br>蚁群算法：从现实中获得的启发。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 建模 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法总结</title>
      <link href="/2023/03/02/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/02/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>  今日我们相聚于此，是为了纪念我们的十大经典排序算法。它的存在对于整个至冬而言，值得足足十天甚至九天的停工学习（确信）<br>  ——————尼古拉斯·公只因sama</p><hr><p> 你说的对，但是《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「提瓦特」的幻想世界，在这里，被神选中的人将被授予「神之眼」，导引元素之力。你将扮演一位名为「旅行者」的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起击败强敌，找回失散的亲人——同时，逐步发掘「原神」的真相。</p><hr><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的意思是数组中的每个数像泡泡一样冒出水面做出排列。</p><p>若要深入理解该排序方法，请看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(length--)</span><br><span class="line"><span class="comment">//每确定一个最大值剩余需要排序的数量-1</span></span><br><span class="line"> &#123;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++);<span class="comment">//交换出最大值排到最末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=a[i];</span><br><span class="line">            a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，我们还可以对这段代码进行优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nt a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//新定义一个flag变量</span></span><br><span class="line"><span class="keyword">while</span>(length--&amp;&amp;flag)<span class="comment">//若flag为0，即前一次排序未发生交换，即排序已经完成，跳出循环，以达成优化。</span></span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="comment">//每确定一个最大值剩余需要排序的数量-1</span></span><br><span class="line"> &#123;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++);<span class="comment">//交换出最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])</span><br><span class="line">        &#123;   </span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//若此次循环中发生过数字交换，则flag为1，若未发生交换，则flag为0，代表该排序已经完成，不需要再进行排序。</span></span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=a[i];</span><br><span class="line">            a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>如果在题中忘记了冒泡排序的原理可以用多个for循环进行多次长度为length的冒泡循环，以至于半个泡都冒不出了，这样你就排序完成了！</del>（胡言乱语）</p><hr><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>本质其实还是冒泡排序，不过与冒泡排序不同的是无法像冒泡排序一样优化。<br>在每次循环中找到一个最小值，并以一个变量做标记，在此次循环结束后将其与第一个变量做交换，以此类推，从而使整个数组从小到大排序。（由大到小同理）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++);</span><br><span class="line"><span class="comment">//一共10个数，排9个即可</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">int</span> k=i;<span class="comment">//当前已知的最高位为默认的第一个数a[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[k])</span><br><span class="line">                k=j;<span class="comment">//当前已知的最高位变更为a[j]</span></span><br><span class="line">        <span class="type">int</span> temp =a [i];<span class="comment">//将已知的最高位与第i项做替换，达成排序目的。</span></span><br><span class="line">        a[i]=a[k];</span><br><span class="line">        a[k]=temp</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>优点：当原始序列基本有序的时候再将数据插入进来，比较方便，也比较高效。<br>其思路相与冒泡排序略微复杂，需要加强理解。<br>其原理是设定一个在数组开头的假想有序数组，每次将该有序数组的数量扩大一位，并将扩大的那一位插入到有序数组的适当位置中完成有序数组的重新排列，直到该有序数组排序完成且长度与原始序列相等，则排序完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)<span class="comment">//此次需要排10个整</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        <span class="comment">//因为第一个数形成了有序数列，并将有序数列的数量扩大至2，在不考虑a[1]数值的情况下，此次排列只需要交换a[1],故将a[i]赋值给临时变量temp</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">//此次排列为由大到小的降序排列，若a[i]的值与之前的有序数列的最后一位a[i-1]相比，a[i]比最小值大的话，则需要将a[i]插入到某一位置，若比最小值小，则无需排列。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;temp&lt;a[j];j--);</span><br><span class="line">            <span class="comment">//此处temp&lt;a[j]的含义是将temp排在第一个比其小的变量中，实现有序数组的降序排列</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">                <span class="comment">//由于temp的插入，有序数组中temp后的元素需要向后移动一位。</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//跳出循环后，将temp赋值给a[j]后面的a[j+1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的本质是插入排序的优化版，在面对比较大的数组时，插入排序总是会一个一个的插入，造成很大的计算量。在希尔排序中，我们先将原数以数组总长的二分之一为间距，每隔一个间距组成一个数组分别进行预插入排列，以此类推再以原数组总长的四分之一为间距进行插入1排列，最后会得到一个数组，对这个数组再进行一次插入排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nt a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//输入10个整数</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i,temp,j,length=length/<span class="number">2</span>;<span class="comment">//length为间距</span></span><br><span class="line"><span class="keyword">while</span>(length&gt;<span class="number">0</span>)<span class="comment">//间距大于0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=length;i&lt;n;i=i+length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;a[j-length])<span class="comment">//对以length为间距的数组进行预插入排列</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[j];</span><br><span class="line">            a[j]=a[j-length];</span><br><span class="line">            a[j-length]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        length=length/<span class="number">2</span>;<span class="comment">//length为间距</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>冒泡排序为什么是神！！！</del></p><hr><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>冒泡排序plus+<br>在快速排序中使用了递归（即反复调用自身），当提到递归的时候，需要注意：要给出结束递归的条件，否则会变成死循环。<br>在快速排序中，你需要选定一个数作为轴数，并以这个轴数为轴，将比其大的数都放到右边，比其小的数都放到左边，完成第一次递归调用的函数的调用，随后将该轴数左右两侧的数组视为独立的单独数组，并对其进行再次递归函数的调用<br>在此借用（@五分钟学算法）的动图<br><img src="https://img-blog.csdnimg.cn/202002091953256.gif" alt="五分钟学算法"><br>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> i = low; <span class="comment">//low,high存为i,j</span></span><br><span class="line">    <span class="type">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= j) <span class="comment">//i=j则本次函数调用结束，可开启下次调用或结束。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> temp = <span class="built_in">array</span>[low];<span class="comment">//temp即为确定是轴数</span></span><br><span class="line">    <span class="keyword">while</span>(i != j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[j] &gt;= temp &amp;&amp; i &lt; j) <span class="comment">//找不到比原数组的上界位大的数则将j向后移动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">array</span>[i] &lt;= temp &amp;&amp; i &lt; j) <span class="comment">//找不到比原数组的下界位大的数则将i向后移动一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j) <span class="comment">//swap即互换函数，在此不做定义</span></span><br><span class="line">        <span class="comment">//ij都找到了并且ij不相等是将对应的值互换</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    swap(<span class="built_in">array</span>[low], <span class="built_in">array</span>[i]);<span class="comment">//将基准temp放于自己的位置，（第i个位置）此时i并非low，i在此时满足i=j。</span></span><br><span class="line"> </span><br><span class="line">    QuickSort(<span class="built_in">array</span>, low, i - <span class="number">1</span>);<span class="comment">//对轴左侧数组进行快速排序函数调用</span></span><br><span class="line">    QuickSort(<span class="built_in">array</span>, i + <span class="number">1</span>, high);<span class="comment">//对轴右侧数组进行快速排序函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并：即将两个有序数列合并成一个有序数列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mergesort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> alen,<span class="type">int</span> b[],<span class="type">int</span> blen,<span class="type">int</span>* temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;alen&amp;&amp;j&lt;blen)<span class="comment">//先排一半进到temp[]里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;b[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k]=a[i];</span><br><span class="line">            k++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k]=b[j];</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;alen&gt;)<span class="comment">//再排后一半到temp[]里</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[k]=a[i];</span><br><span class="line">        k++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;blen&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k]=b[i];</span><br><span class="line">        k++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="堆排序（内堆）（待更新）"><a href="#堆排序（内堆）（待更新）" class="headerlink" title="堆排序（内堆）（待更新）"></a>堆排序（内堆）（待更新）</h1><hr><h1 id="堆排序（外堆）（待更新）"><a href="#堆排序（外堆）（待更新）" class="headerlink" title="堆排序（外堆）（待更新）"></a>堆排序（外堆）（待更新）</h1><hr><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>利用数组下标本身的有序性完成排列。<br>代码极其简单。<br><img src="https://img-blog.csdnimg.cn/c43908d6854a4be38c68060f0293d79b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP54y_5qGl,size_20,color_FFFFFF,t_70,g_se,x_16" alt="计数排序"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp[<span class="number">100</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">countsort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[arr[i]]++;<span class="comment">//原数组的数到对应自定数组的对应下标+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>,j=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(temp[i]--)</span><br><span class="line">            arr[j++]=i;<span class="comment">//自定数组每有一个1则输出到arr[]一个对应的数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>非比较算法，将整数按照每个位数分别比较。<br>在此我借用（@小c哈哈哈）的文章来进行演示。<br><img src="https://img-blog.csdnimg.cn/2021012618502516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aV9oYWhhaGE=,size_16,color_FFFFFF,t_70" alt="1"><br><img src="https://img-blog.csdnimg.cn/2021012618565523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aV9oYWhhaGE=,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210126190427561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aV9oYWhhaGE=,size_16,color_FFFFFF,t_70"><br>将数按照个位数大小存放，并按顺序取出，然后将按照十位数大小存放，并按顺序取出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> temp[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> bucket[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">maxBit</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//行这些代码在求n个元素的最大值 </span></span><br><span class="line"><span class="type">int</span> maxData = data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(maxData&lt;data[i])</span><br><span class="line">maxData=data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这些代码在求最大值的位数是多少 </span></span><br><span class="line"><span class="type">int</span> d=<span class="number">1</span>;    <span class="comment">//d用来计数最大值的位数，因为既然是一个数，肯定至少有1位，所以d初始化为1 </span></span><br><span class="line"><span class="keyword">while</span>(maxData&gt;=<span class="number">10</span>)  <span class="comment">//将最大值不断/10，计算位数 </span></span><br><span class="line">&#123;</span><br><span class="line">maxData/=<span class="number">10</span>;</span><br><span class="line">d++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">radixsort</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> n)</span>  <span class="comment">//基数排序 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> d = maxBit(data,n);  <span class="comment">//求出最大位数</span></span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=d;i++)   <span class="comment">//进行d次排序</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)   <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">&#123;</span><br><span class="line">bucket[j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)    <span class="comment">//统计每个桶的元素个数 </span></span><br><span class="line">&#123;</span><br><span class="line">k=(data[j]/radix)%<span class="number">10</span>;</span><br><span class="line">bucket[k]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键代码1 </span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            bucket[j] = bucket[j - <span class="number">1</span>] + bucket[j]; </span><br><span class="line">       </span><br><span class="line">       <span class="comment">//关键代码2 </span></span><br><span class="line"><span class="keyword">for</span>(j = n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) </span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            temp[bucket[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            bucket[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = temp[j];</span><br><span class="line">            </span><br><span class="line">        radix = radix * <span class="number">10</span>;  <span class="comment">//个位  -》 十位  -》百位 -》…… </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">34</span>,<span class="number">4</span>&#125;;   </span><br><span class="line">radixsort(a,<span class="number">4</span>);         <span class="comment">//a十待排序的数组 ，4是元素个数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode接入chatgpt</title>
      <link href="/2023/02/22/VScode%E6%8E%A5%E5%85%A5chatgpt/"/>
      <url>/2023/02/22/VScode%E6%8E%A5%E5%85%A5chatgpt/</url>
      
        <content type="html"><![CDATA[<p>随着Chatgpt的火爆，越来越多的人开始寻找更便捷的方式使用Chatgpt在工作和学习方面辅助自己。</p><p>Chatgpt已于2023年三月初被墙国内ip已经无法正常访问，请各位悉知。</p><p>本教程分为以下三个部分：  </p><ol><li>下载vscode以及为vscode配置c语言环境。  </li><li>openai-key的获取</li><li>将Chatgpt接入vscode</li></ol><hr><h1 id="下载vscode以及为vscode配置c语言环境"><a href="#下载vscode以及为vscode配置c语言环境" class="headerlink" title="下载vscode以及为vscode配置c语言环境"></a>下载vscode以及为vscode配置c语言环境</h1><h2 id="1-下载vscode下载链接"><a href="#1-下载vscode下载链接" class="headerlink" title="1. 下载vscode下载链接"></a>1. 下载vscode<a href="https://code.visualstudio.com/Download">下载链接</a></h2><p><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/2a5aebadf0f1b59db9adac2b3f7c551ad67dab61.png" alt="下载页面"><br>根据自己的系统来选择适合自己的vscode版本，我这里以windows版的vscode为例。<br>如果你嫌弃官网下载速度慢，可以通过我提供的链接下载截至发布日期最新版的vscode windows1.75.1版本。<br>链接：<a href="https://pan.baidu.com/s/1tS2S4EaJb5_eStXE9LuGFg?pwd=1145">百度网盘链接</a><br>提取码：1145   </p><h2 id="2-安装vscode"><a href="#2-安装vscode" class="headerlink" title="2. 安装vscode"></a>2. 安装vscode</h2><p>本步骤没什么要注意的，注意勾选同意协议，以及创建快捷方式即可。</p><h2 id="3-下载vscode自动配置c语言环境工具"><a href="#3-下载vscode自动配置c语言环境工具" class="headerlink" title="3.下载vscode自动配置c语言环境工具"></a>3.下载vscode自动配置c语言环境工具</h2><p><a href="https://github.com/VSCodeConfigHelper/v4">下载链接</a><br>本工具由北京大学谷雨同学开发。<br>点击Releasses下的v4.06<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/ec4ae3db9a7ff03ca431288d205cc51ff77b09c3.png" alt="下载页面"><br>在.7z文件处选择一个属于自己操作系统的文件并且点击下载。<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/32d1a3baf65b7f53598bf4873832c934b0dd43d2.png" alt="下载页面"></p><h2 id="4-配置c语言环境"><a href="#4-配置c语言环境" class="headerlink" title="4.配置c语言环境"></a>4.配置c语言环境</h2><p>接下来我以windows版为例。<br>在资源管理器右键解压到当前文件夹。<br>双击 vsch.exe打开程序。 </p><h3 id="1-确认vscode路径"><a href="#1-确认vscode路径" class="headerlink" title="1. 确认vscode路径"></a>1. 确认vscode路径</h3><h3 id="2-选择编译器"><a href="#2-选择编译器" class="headerlink" title="2. 选择编译器"></a>2. 选择编译器</h3><p>安装方式   </p><ul><li><ol><li>跟随c语言环境配置工具的教程安装(推荐，建议不成功再选用第二种方式)</li></ol></li><li><ol start="2"><li>手动安装方式。(如下)</li></ol></li></ul><p>我选用的是MinGW编译器6.3.0版本<br><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">下载链接</a><br>点击下载链接后，不要下载上面的文件，往下划到MinGW-W64 Online Installer下载列表。<br>如果你嫌下载太慢，可以通过我提供的百度网盘链接下载。<br>链接：<a href="https://pan.baidu.com/s/1oZYnZWDe5Lx1Hg4d8EDTTQ?pwd=1145">百度网盘</a><br>提取码：1145<br>下载完成后点击安装<br><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/e6339351e71fe125b9cb163a12c5668aca07f1e8.png" alt="安装界面"><br>Veision：选最高<br>Architechture：64位系统选 x86_64 32位系统选i686。(现在大多数系统都是64位的)<br>Threads:Windows系统选择win32  Linux、Unix、Mac OS 等选择posix。<br>Exception：选seh<br>然后无脑下一步。<br>完成安装。  </p><h3 id="3-选择工作文件夹"><a href="#3-选择工作文件夹" class="headerlink" title="3. 选择工作文件夹"></a>3. 选择工作文件夹</h3><h3 id="4-配置选项（默认即可）"><a href="#4-配置选项（默认即可）" class="headerlink" title="4. 配置选项（默认即可）"></a>4. 配置选项（默认即可）</h3><h3 id="5-配置完成"><a href="#5-配置完成" class="headerlink" title="5. 配置完成"></a>5. 配置完成</h3><p>按执行测试文件，若能成功运行，则成功。<br>参考文章：<a href="https://zhuanlan.zhihu.com/p/355510947">https://zhuanlan.zhihu.com/p/355510947</a>  </p><hr><h1 id="openai-key的获取"><a href="#openai-key的获取" class="headerlink" title="openai-key的获取"></a>openai-key的获取</h1><p><a href="https://auth0.openai.com/u/signup/identifier?state=hKFo2SBqaXBuQUQ2TkszRUhWRGN0UjBNd3cxX3pYR2hmN2xzQqFur3VuaXZlcnNhbC1sb2dpbqN0aWTZIGJzVVRBVXMxeGl3VWJQOUtJNGJJNFMxdWNVNkVNQlVSo2NpZNkgRFJpdnNubTJNdTQyVDNLT3BxZHR3QjNOWXZpSFl6d0Q">注册链接</a> </p><p> 注：(此方法需要乘坐魔法扫帚前往美国开启全局模式才可注册)<br> 更详细的注册方法请自行在网上查阅。还可以在网络上自行购买openai的账号。</p><p> 附：<a href="https://cloud.tencent.com/developer/article/2190154">注册openai账号的教程</a>（作者：JanYork_小简）</p><p> 在您拥有账号后，便可以开启接下来的教程<br> <img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/a22e42a612532fc8d2151a028c7fb9f87bf5baf9.png" alt="注册链接"><br> 点击屏幕右上角个人头像<br> <img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/f9678baa78c193ec73c50669b8ac7d3daa1fdbbb.png" alt="注册链接"> 点击“View API keys”选项<br> 然后在新出现的页面中点击“Creat new secert key”选项以生产apikey<br> (注意：此key要保存好，对于这个key，你只有这一次保存复制的机会)</p><hr><h1 id="将Chatgpt接入vscode"><a href="#将Chatgpt接入vscode" class="headerlink" title="将Chatgpt接入vscode"></a>将Chatgpt接入vscode</h1><h2 id="调节vscode到中文并应用chatgpt插件"><a href="#调节vscode到中文并应用chatgpt插件" class="headerlink" title="调节vscode到中文并应用chatgpt插件"></a>调节vscode到中文并应用chatgpt插件</h2><ul><li><p>打开已经配置好的vscode</p></li><li><p>点击最左侧扩展选项（左侧第四个）</p></li><li><p>搜索  Chinese (Simplified)  和 chatgpt中文版 两个插件</p></li><li><p>下载完成后需要重启vscode应用中文模式</p></li><li><p>由于国内模式过于垃圾我们要使用并配置国外模式  </p></li><li><p>由于chatgpt中文版插件内关于配置的教程已经描述的十分详细，故在此不多赘述。</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=WhenSunset.chatgpt-china">chatgpt中文版配置国外模式教程</a></p></li><li><p>配置完成后可以使用左侧主侧栏第五个选项“Chat-Gpt中文版即可开始对话”</p></li><li><p>此外，选中具体代码即可让chatgpt对你的代码进行分析与解释。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Chatgpt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人常用网站分享</title>
      <link href="/2022/08/01/%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/"/>
      <url>/2022/08/01/%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="网易见外工作台"><a href="#网易见外工作台" class="headerlink" title="网易见外工作台"></a>网易见外工作台</h2><p><a href="https://jianwai.youdao.com/index/0">网易见外工作台</a><br>功能：登录网易账号即可使用  </p><ul><li>视频翻译，ai自动生成中英双语字幕，并且可将字幕文件导入pr等视频编辑软件进行再度编辑。</li><li>字幕翻译：将生肉的字幕文件上传至工作台，即可导出熟肉字幕。</li><li>文档翻译： 文档快速翻译，支持在线编辑与本地导出。</li><li>语言翻译，上传音频，即可自动生成对应视频音频的文字文档。</li><li>会议同传：（需付费）在线会议实时转写与同步翻译，支持文本的编辑与导出。</li><li>图片翻译：支持多场景下的文字识别，将识别结果一键翻译。</li></ul><hr><h2 id="中国科学技术大学测速网站"><a href="#中国科学技术大学测速网站" class="headerlink" title="中国科学技术大学测速网站"></a>中国科学技术大学测速网站</h2><p><a href="http://test.ustc.edu.cn/">中国科学技术大学测速网站</a><br>功能：简洁好用的测速网站</p><ul><li>可以测速网络延迟 延迟抖动 下载速度 上传速度 以及ipv6和ipv4</li></ul><hr><h2 id="MuseTransfer"><a href="#MuseTransfer" class="headerlink" title="MuseTransfer"></a>MuseTransfer</h2><p><a href="https://musetransfer.com/">MuseTransfer</a><br>功能：免费传输文件（不限速）（微信登录），并且支持收集文件。</p><hr><h2 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h2><p><a href="https://www.processon.com/">ProcessOn</a><br>功能：在线免费制图工具（微信登录），可以完美胜任制作流程如图等图片。</p><hr><h2 id="LearningMusic"><a href="#LearningMusic" class="headerlink" title="LearningMusic"></a>LearningMusic</h2><p><a href="https://learningmusic.ableton.com/zh-Hans/">LearningMusic</a><br>功能：简洁好用的的音乐学习网站，很有创意。分设有节奏，音符和音阶，和弦，贝斯，旋律，乐曲结构等章节，适合入门者学习。</p><hr><h2 id="大学生活质量指北"><a href="#大学生活质量指北" class="headerlink" title="大学生活质量指北"></a>大学生活质量指北</h2><p><a href="https://cn.colleges.chat/">大学生活质量指北</a><br>功能：一个由tg频道发起的调查项目，总结了国内各大高校的大学生活质量，有一定的参考价值。</p><hr><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><p><a href="https://www.runoob.com/">菜鸟教程</a><br>功能：网站内包含各种语言的学习教程以及有丰富的例子，是一个比较优秀的资&#x3D;语言资料网站和学习网站。</p><hr><h2 id="ocs网课助手"><a href="#ocs网课助手" class="headerlink" title="ocs网课助手"></a>ocs网课助手</h2><p><a href="https://docs.ocsjs.com/">ocs网课助手</a><br>专注于帮助大学生从网课中释放出来。让自己的时间把握在自己的手中。支持学习通自动刷课，答题，在网站内有丰富的教程以帮助使用。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '1';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/优设好身体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '2';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/甜甜圈海报字体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '3';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/Consolas.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '4';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/HYTangMeiRen55W.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '5';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/MiSans.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '6';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/MiSans.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '7';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/ZhuZiAWan2.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '8';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/ZhuZiAWan2.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: '9';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/ZhuZiAJuanJWD.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 链接样式 */#article-container a {  color: var(--theme-color);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-关于date-2023-1-9-13-54-00"><a href="#title-关于date-2023-1-9-13-54-00" class="headerlink" title="title:关于date :2023-1-9 13:54:00"></a>title:关于<br>date :2023-1-9 13:54:00</h2>]]></content>
      
    </entry>
    
    
  
</search>
